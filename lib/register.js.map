{"version":3,"sources":["../src/register.js"],"names":["query","parse","window","location","search","phase","selectKind","selectStory","searchScreenshotWrappersByStory","kind","story","api","channel","inited","mounted","Promise","resolve","onInit","context","push","onMount","length","onResolve","contexts","removeListener","COMPONENT_INIT","COMPONENT_MOUNT","on","setTimeout","searchTargetStories","reject","once","stories","storiesPlainList","group","map","cur","then","results","COMPONENT_ERROR","register","name","getChannel","PREPARE","CAPTURE","setScreenshotStories","COMPONENT_READY","readyComponentScreenshot","Error","failureScreenshot"],"mappings":"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","file":"register.js","sourcesContent":["import 'babel-polyfill';\nimport { getStorybook } from '@storybook/react'; // eslint-disable-line\nimport { flattenDeep } from 'lodash';\nimport { compose, flattenDepth, map } from 'lodash/fp';\nimport addons from '@storybook/addons';\nimport qs from 'query-string';\nimport {\n  PhaseTypes,\n  EventTypes,\n  SEARCH_COMPONENT_TIMEOUT,\n} from './constants';\nimport { promiseChain } from './internal/utils';\nimport pkg from '../package.json';\n\n\nconst query = qs.parse(window.location.search);\nconst phase = query['chrome-screenshot'];\nconst selectKind = query.selectKind;\nconst selectStory = query.selectStory;\n\nconst searchScreenshotWrappersByStory = (kind, story, api, channel) => {\n  const inited = [];\n  const mounted = [];\n\n  // One story can have several usage of withScreenshot.\n  // Using the events from teh ScreenshotWrapper we try to know about the wrappers\n  // events are firing in this sequence. init, mount\n  // If story doesn't have any withScreenshot wrappers, we handle it with delay.\n  // Unfortunately, we can directly check if the story has the wrapper,\n  // so we hope that init event will be fired in SEARCH_COMPONENT_TIMEOUT miliseconds.\n  // Overwise, we think, that story doesn't have the wrappers\n\n  // Why we use 2 kind of events: init and mount?\n  // we use 2 events, init and mount, because in this way\n  // we can recognize when all wrappers are mounted.\n  // Init events always fire before a mount events.\n  // so when we handle first mount event we know the total count of the wrappers.\n\n  return new Promise((resolve) => {\n    function onInit(context) {\n      if (context.kind !== kind || context.story !== story) return;\n      inited.push(context);\n    }\n    function onMount(context) {\n      if (context.kind !== kind || context.story !== story) return;\n      mounted.push(context);\n      if (mounted.length === inited.length) {\n        onResolve(mounted); // eslint-disable-line\n      }\n    }\n    function onResolve(contexts) {\n      resolve(contexts);\n      channel.removeListener(EventTypes.COMPONENT_INIT, onInit);\n      channel.removeListener(EventTypes.COMPONENT_MOUNT, onMount);\n    }\n    channel.on(EventTypes.COMPONENT_INIT, onInit);\n    channel.on(EventTypes.COMPONENT_MOUNT, onMount);\n\n    api.selectStory(kind, story);\n    setTimeout(() => {\n      if (inited.length === 0) onResolve([]);\n    }, SEARCH_COMPONENT_TIMEOUT);\n  });\n};\n\nconst searchTargetStories = (channel, api) => new Promise((resolve, reject) => {\n  channel.once('setStories', ({ stories }) => {\n    const storiesPlainList = compose(\n      flattenDepth(2),\n      map(group => group.stories.map(story => ({ kind: group.kind, story }))) // eslint-disable-line\n    )(stories);\n\n    promiseChain(\n      storiesPlainList,\n      cur => searchScreenshotWrappersByStory(cur.kind, cur.story, api, channel) // eslint-disable-line\n    ).then((results) => {\n      const contexts = flattenDeep(results);\n      resolve(contexts);\n    }, reject);\n\n    channel.on(EventTypes.COMPONENT_ERROR, reject);\n  });\n});\n\n\naddons.register(pkg.name, async (api) => {\n  if (!phase) {\n    return;\n  }\n\n  try {\n    const channel = addons.getChannel();\n\n    switch (phase) {\n      case PhaseTypes.PREPARE:\n        await window.setScreenshotStories(await searchTargetStories(channel, api));\n        return;\n\n      case PhaseTypes.CAPTURE:\n        channel.on(EventTypes.COMPONENT_READY, ({ kind, story }) => {\n          if (selectKind === kind && selectStory === story) {\n            window.readyComponentScreenshot();\n          }\n        });\n        api.selectStory(selectKind, selectStory);\n        break;\n\n      default: throw new Error(`An unknown phase called \"${phase}\" is being executed.`);\n    }\n  } catch (e) {\n    window.failureScreenshot(e);\n  }\n});\n"]}